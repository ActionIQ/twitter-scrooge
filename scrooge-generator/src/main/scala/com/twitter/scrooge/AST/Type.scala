package com.twitter.scrooge.ast

sealed trait FunctionType extends TypeNode
case object Void extends FunctionType
case object OnewayVoid extends FunctionType
sealed trait FieldType extends FunctionType
sealed trait BaseType extends FieldType
case object TBool extends BaseType
case object TByte extends BaseType
case object TI16 extends BaseType
case object TI32 extends BaseType
case object TI64 extends BaseType
case object TDouble extends BaseType
case object TString extends BaseType
case object TBinary extends BaseType

/**
 * AnnotatedFieldType is used to be able to annotate arbitrary FieldTypes.
 * The current use case is to allow annotating types inside of collection hierarchies.
 * In the future this can/should be expanded for type annotations in general.
 *
 * Note: please use AnnotatedFieldType.build to construct instances of this.
 *
 * @param underlying the type being annotated
 * @param annos annotations applied to the underlying type
 */
case class AnnotatedFieldType private (underlying: FieldType, annos: Map[String, String])
    extends FieldType {
  require(annos.nonEmpty, "Cannot construct an AnnotatedFieldType with empty annotations.")

  /**
   * Once type annotations from underlying types have fully migrated to
   * AnnotatedFieldType, this will not be necessary anymore.
   */
  def unwrap: FieldType = underlying match {
    case s: StructType => s.copy(struct = s.struct.withAnnotations(annos))
    case e: EnumType => e.copy(enum = e.enum.copy(annotations = annos))
    // Other types don't keep track of annotations, so there is nothing to propagate
    case otherwise => otherwise
  }
  def annotations: Map[String, String] = annos
}

/**
 * Type builder utils where we make the best effort to unwrap
 * nested annotated types and avoid producing extra wrappers
 * where possible.
 */
object AnnotatedFieldType {
  def wrap(t: FieldType, annotations: Map[String, String]): FieldType = {
    if (annotations.isEmpty) t
    else
      t match {
        case t: AnnotatedFieldType =>
          new AnnotatedFieldType(t.underlying, t.annotations ++ annotations)
        case otherwise => new AnnotatedFieldType(otherwise, annotations)
      }
  }
}

/**
 * ReferenceType is generated by ThriftParser in the frontend and
 * resolved by TypeResolver. There will only be ReferenceTypes after
 * resolution seen by the backend when self-reference structs,
 * mutually recursive structs, or references to further definitions
 * (structs/enums) are present in the Document.
 */
case class ReferenceType(id: Identifier) extends FieldType

sealed trait NamedType extends FieldType {
  def sid: SimpleID

  /** Filename of the containing file if the type is included from another file */
  def scopePrefix: Option[Identifier]
}

case class StructType(struct: StructLike, scopePrefix: Option[Identifier] = None)
    extends NamedType {
  val sid: SimpleID = struct.sid
  override def toString: String = "Struct(?)"
}

case class EnumType(enum: Enum, scopePrefix: Option[Identifier] = None) extends NamedType {
  val sid: SimpleID = enum.sid
  override def toString: String = "Enum(?)"
}

sealed abstract class ContainerType(cppType: Option[String]) extends FieldType

case class MapType(keyType: FieldType, valueType: FieldType, cppType: Option[String])
    extends ContainerType(cppType) {

  override def toString: String = s"Map($keyType, $valueType)"
}

case class SetType(eltType: FieldType, cppType: Option[String]) extends ContainerType(cppType) {
  override def toString: String = s"Set($eltType)"
}

case class ListType(eltType: FieldType, cppType: Option[String]) extends ContainerType(cppType) {
  override def toString: String = s"List($eltType)"
}
